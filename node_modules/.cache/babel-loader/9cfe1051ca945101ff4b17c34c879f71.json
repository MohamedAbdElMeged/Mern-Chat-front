{"ast":null,"code":"/*\n *                 Copyright (C) 2015 Shane Carr and others\n *                               X11 License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the names of the authors or copyright\n * holders shall not be used in advertising or otherwise to promote the sale,\n * use or other dealings in this Software without prior written authorization\n * from the authors or copyright holders.\n */\n// Do not check function indentation because this is intentionally ignored in order to preserve history in git.\n\n/* eslint-disable indent */\n\n/*\n * A client-side JavaScript object to handle file uploads to a Node.JS server\n * via Socket.IO.\n * @implements EventTarget\n * @param {SocketIO} socket The current Socket.IO connection.\n */\n(function (scope, name, factory) {\n  /* eslint-disable no-undef */\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    scope[name] = factory();\n  }\n  /* eslint-enable no-undef */\n\n})(this, \"SocketIOFileUpload\", function () {\n  return function (socket, options) {\n    \"use strict\";\n\n    var self = this; // avoids context issues\n    // Check for compatibility\n\n    if (!window.File || !window.FileReader) {\n      throw new Error(\"Socket.IO File Upload: Browser Not Supported\");\n    }\n\n    if (!window.siofu_global) {\n      window.siofu_global = {\n        instances: 0,\n        downloads: 0\n      };\n    } // Private and Public Variables\n\n\n    var callbacks = {},\n        uploadedFiles = {},\n        chunkCallbacks = {},\n        readyCallbacks = {},\n        communicators = {};\n\n    var _getOption = function (key, defaultValue) {\n      if (!options) {\n        return defaultValue;\n      }\n\n      return options[key] || defaultValue;\n    };\n\n    self.fileInputElementId = \"siofu_input_\" + window.siofu_global.instances++;\n    self.resetFileInputs = true;\n    self.useText = _getOption(\"useText\", false);\n    self.serializedOctets = _getOption(\"serializedOctets\", false);\n    self.useBuffer = _getOption(\"useBuffer\", true);\n    self.chunkSize = _getOption(\"chunkSize\", 1024 * 100); // 100kb default chunk size\n\n    self.topicName = _getOption(\"topicName\", \"siofu\");\n    /**\n    * WrapData allow you to wrap the Siofu messages into a predefined format.\n    * You can then easily use Siofu packages even in strongly typed topic.\n    * wrapData can be a boolean or an object. It is false by default.\n    * If wrapData is true it will allow you to send all the messages to only one topic by wrapping the siofu actions and messages.\n    *\n    * ex:\n    {\n    \taction: 'complete',\n    \tmessage: {\n    \t id: id,\n    \t success: success,\n    \t detail: fileInfo.clientDetail\n    \t}\n    }\n    *\n    * If wrapData is an object constituted of two mandatory key and one optional:\n    * wrapKey and unwrapKey (mandatory): Corresponding to the key used to wrap the siofu data and message\n    * additionalData (optional): Corresponding to the data to send along with file data\n    *\n    * ex:\n    * if wrapData = {\n    \twrapKey: {\n    \t\taction: 'actionType',\n    \t\tmessage: 'data'\n    \t},\n    \tunwrapKey: {\n    \t\taction: 'actionType',\n    \t\tmessage: 'message'\n    \t},\n    \tadditionalData: {\n    \t\tacknowledgement: true\n    \t}\n    }\n    * When Siofu will send for example a complete message this will send:\n    *\n    {\n    \tacknowledgement: true,\n    \tactionType: 'complete',\n    \tdata: {\n    \t id: id,\n    \t success: success,\n    \t detail: fileInfo.clientDetail\n    \t}\n    }\n    * and it's waiting from client data formatted like this:\n    *\n    {\n    \tactionType: '...',\n    \tmessage: {...}\n    }\n    * /!\\ If wrapData is wrong configured is interpreted as false /!\\\n    */\n\n    self.wrapData = _getOption(\"wrapData\", false);\n\n    var _isWrapDataWellConfigured = function () {\n      if (typeof self.wrapData === \"boolean\") {\n        return true;\n      }\n\n      if (typeof self.wrapData !== \"object\" || Array.isArray(self.wrapData)) {\n        return false;\n      }\n\n      if (!self.wrapData.wrapKey || typeof self.wrapData.wrapKey.action !== \"string\" || typeof self.wrapData.wrapKey.message !== \"string\" || !self.wrapData.unwrapKey || typeof self.wrapData.unwrapKey.action !== \"string\" || typeof self.wrapData.unwrapKey.message !== \"string\") {\n        return false;\n      }\n\n      return true;\n    };\n    /**\n     * Allow user to access to some private function to customize message reception.\n     * This is used if you specified wrapOptions on the client side and have to manually bind message to callback.\n     */\n\n\n    self.exposePrivateFunction = _getOption(\"exposePrivateFunction\", false);\n\n    var _getTopicName = function (topicExtension) {\n      if (self.wrapData) {\n        return self.topicName;\n      }\n\n      return self.topicName + topicExtension;\n    };\n\n    var _wrapData = function (data, action) {\n      if (!_isWrapDataWellConfigured() || !self.wrapData) {\n        return data;\n      }\n\n      var dataWrapped = {};\n\n      if (self.wrapData.additionalData) {\n        Object.assign(dataWrapped, self.wrapData.additionalData);\n      }\n\n      var actionKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.action === \"string\" ? self.wrapData.wrapKey.action : \"action\";\n      var messageKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.message === \"string\" ? self.wrapData.wrapKey.message : \"message\";\n      dataWrapped[actionKey] = action;\n      dataWrapped[messageKey] = data;\n      return dataWrapped;\n    };\n    /**\n     * Private method to dispatch a custom event on the instance.\n     * @param  {string} eventName  Name for which listeners can listen.\n     * @param  {object} properties An object literal with additional properties\n     *                             to be attached to the event object.\n     * @return {boolean} false if any callback returned false; true otherwise\n     */\n\n\n    var _dispatch = function (eventName, properties) {\n      var evnt = document.createEvent(\"Event\");\n      evnt.initEvent(eventName, false, false);\n\n      for (var prop in properties) {\n        if (properties.hasOwnProperty(prop)) {\n          evnt[prop] = properties[prop];\n        }\n      }\n\n      return self.dispatchEvent(evnt);\n    };\n    /**\n     * Private method to bind an event listener.  Useful to ensure that all\n     * events have been unbound.  Inspired by Backbone.js.\n     */\n\n\n    var _listenedReferences = [];\n\n    var _listenTo = function (object, eventName, callback, bubble) {\n      object.addEventListener(eventName, callback, bubble);\n\n      _listenedReferences.push(arguments);\n    };\n\n    var _stopListeningTo = function (object, eventName, callback, bubble) {\n      if (object.removeEventListener) {\n        object.removeEventListener(eventName, callback, bubble);\n      }\n    };\n\n    var _stopListening = function () {\n      for (var i = _listenedReferences.length - 1; i >= 0; i--) {\n        _stopListeningTo.apply(this, _listenedReferences[i]);\n      }\n\n      _listenedReferences = [];\n    };\n    /**\n     * Private closure for the _load function.\n     * @param  {File} file A W3C File object\n     * @return {void}\n     */\n\n\n    var _loadOne = function (file) {\n      // First check for file size\n      if (self.maxFileSize !== null && file.size > self.maxFileSize) {\n        _dispatch(\"error\", {\n          file: file,\n          message: \"Attempt by client to upload file exceeding the maximum file size\",\n          code: 1\n        });\n\n        return;\n      } // Dispatch an event to listeners and stop now if they don't want\n      // this file to be uploaded.\n\n\n      var evntResult = _dispatch(\"start\", {\n        file: file\n      });\n\n      if (!evntResult) return; // Scope variables\n\n      var reader = new FileReader(),\n          id = window.siofu_global.downloads++,\n          uploadComplete = false,\n          useText = self.useText,\n          offset = 0,\n          newName;\n      if (reader._realReader) reader = reader._realReader; // Support Android Crosswalk\n\n      uploadedFiles[id] = file; // An object for the outside to use to communicate with us\n\n      var communicator = {\n        id: id\n      }; // Calculate chunk size\n\n      var chunkSize = self.chunkSize;\n      if (chunkSize >= file.size || chunkSize <= 0) chunkSize = file.size; // Private function to handle transmission of file data\n\n      var transmitPart = function (start, end, content) {\n        var isBase64 = false;\n\n        if (!useText) {\n          try {\n            var uintArr = new Uint8Array(content); // Support the transmission of serialized ArrayBuffers\n            // for experimental purposes, but default to encoding the\n            // transmission in Base 64.\n\n            if (self.serializedOctets) {\n              content = uintArr;\n            } else if (self.useBuffer) {\n              content = uintArr.buffer;\n            } else {\n              isBase64 = true;\n              content = _uint8ArrayToBase64(uintArr);\n            }\n          } catch (error) {\n            socket.emit(_getTopicName(\"_done\"), _wrapData({\n              id: id,\n              interrupt: true\n            }, \"done\"));\n            return;\n          }\n        } // TODO override the send data\n\n\n        socket.emit(_getTopicName(\"_progress\"), _wrapData({\n          id: id,\n          size: file.size,\n          start: start,\n          end: end,\n          content: content,\n          base64: isBase64\n        }, \"progress\"));\n      }; // Callback when tranmission is complete.\n\n\n      var transmitDone = function () {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id\n        }, \"done\"));\n      }; // Load a \"chunk\" of the file from offset to offset+chunkSize.\n      //\n      // Note that FileReader has its own \"progress\" event.  However,\n      // it has not proven to be reliable enough for production. See\n      // Stack Overflow question #16713386.\n      //\n      // To compensate, we will manually load the file in chunks of a\n      // size specified by the user in the uploader.chunkSize property.\n\n\n      var processChunk = function () {\n        // Abort if we are told to do so.\n        if (communicator.abort) return;\n        var chunk = file.slice(offset, Math.min(offset + chunkSize, file.size));\n\n        if (useText) {\n          reader.readAsText(chunk);\n        } else {\n          reader.readAsArrayBuffer(chunk);\n        }\n      }; // Callback for when the reader has completed a load event.\n\n\n      var loadCb = function (event) {\n        // Abort if we are told to do so.\n        if (communicator.abort) return; // Transmit the newly loaded data to the server and emit a client event\n\n        var bytesLoaded = Math.min(offset + chunkSize, file.size);\n        transmitPart(offset, bytesLoaded, event.target.result);\n\n        _dispatch(\"progress\", {\n          file: file,\n          bytesLoaded: bytesLoaded,\n          name: newName\n        }); // Get ready to send the next chunk\n\n\n        offset += chunkSize;\n\n        if (offset >= file.size) {\n          // All done!\n          transmitDone();\n\n          _dispatch(\"load\", {\n            file: file,\n            reader: reader,\n            name: newName\n          });\n\n          uploadComplete = true;\n        }\n      };\n\n      _listenTo(reader, \"load\", loadCb); // Listen for an \"error\" event.  Stop the transmission if one is received.\n\n\n      _listenTo(reader, \"error\", function () {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id,\n          interrupt: true\n        }, \"done\"));\n\n        _stopListeningTo(reader, \"load\", loadCb);\n      }); // Do the same for the \"abort\" event.\n\n\n      _listenTo(reader, \"abort\", function () {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id,\n          interrupt: true\n        }, \"done\"));\n\n        _stopListeningTo(reader, \"load\", loadCb);\n      }); // Transmit the \"start\" message to the server.\n\n\n      socket.emit(_getTopicName(\"_start\"), _wrapData({\n        name: file.name,\n        mtime: file.lastModified,\n        meta: file.meta,\n        size: file.size,\n        encoding: useText ? \"text\" : \"octet\",\n        id: id\n      }, \"start\")); // To avoid a race condition, we don't want to start transmitting to the\n      // server until the server says it is ready.\n\n      var readyCallback = function (_newName) {\n        newName = _newName;\n        processChunk();\n      };\n\n      var chunkCallback = function () {\n        if (!uploadComplete) processChunk();\n      };\n\n      readyCallbacks[id] = readyCallback;\n      chunkCallbacks[id] = chunkCallback;\n      return communicator;\n    };\n    /**\n     * Private function to load the file into memory using the HTML5 FileReader object\n     * and then transmit that file through Socket.IO.\n     *\n     * @param  {FileList} files An array of files\n     * @return {void}\n     */\n\n\n    var _load = function (files) {\n      // Iterate through the array of files.\n      for (var i = 0; i < files.length; i++) {\n        // Evaluate each file in a closure, because we will need a new\n        // instance of FileReader for each file.\n        var communicator = _loadOne(files[i]);\n\n        communicators[communicator.id] = communicator;\n      }\n    };\n    /**\n     * Private function to fetch an HTMLInputElement instance that can be used\n     * during the file selection process.\n     * @return {void}\n     */\n\n\n    var _getInputElement = function () {\n      var inpt = document.getElementById(self.fileInputElementId);\n\n      if (!inpt) {\n        inpt = document.createElement(\"input\");\n        inpt.setAttribute(\"type\", \"file\");\n        inpt.setAttribute(\"id\", self.fileInputElementId);\n        inpt.style.display = \"none\";\n        document.body.appendChild(inpt);\n      }\n\n      return inpt;\n    };\n    /**\n     * Private function to remove an HTMLInputElement created by this instance\n     * of SIOFU.\n     *\n     * @return {void}\n     */\n\n\n    var _removeInputElement = function () {\n      var inpt = document.getElementById(self.fileInputElementId);\n\n      if (inpt) {\n        inpt.parentNode.removeChild(inpt);\n      }\n    };\n\n    var _baseFileSelectCallback = function (files) {\n      if (files.length === 0) return; // Ensure existence of meta property on each file\n\n      for (var i = 0; i < files.length; i++) {\n        if (!files[i].meta) files[i].meta = {};\n      } // Dispatch the \"choose\" event\n\n\n      var evntResult = _dispatch(\"choose\", {\n        files: files\n      }); // If the callback didn't return false, continue with the upload\n\n\n      if (evntResult) {\n        _load(files);\n      }\n    };\n    /**\n     * Private function that serves as a callback on file input.\n     * @param  {Event} event The file input change event\n     * @return {void}\n     */\n\n\n    var _fileSelectCallback = function (event) {\n      var files = event.target.files || event.dataTransfer.files;\n      event.preventDefault();\n\n      _baseFileSelectCallback(files);\n\n      if (self.resetFileInputs) {\n        try {\n          event.target.value = \"\"; //for IE11, latest Chrome/Firefox/Opera...\n        } catch (err) {// ignore\n        }\n\n        if (event.target.value) {\n          //for IE5 ~ IE10\n          var form = document.createElement(\"form\"),\n              parentNode = event.target.parentNode,\n              ref = event.target.nextSibling;\n          form.appendChild(event.target);\n          form.reset();\n          parentNode.insertBefore(event.target, ref);\n        }\n      }\n    };\n    /**\n     * Submit files at arbitrary time\n     * @param {FileList} files Files received form the input element.\n     * @return {void}\n     */\n\n\n    this.submitFiles = function (files) {\n      if (files) {\n        _baseFileSelectCallback(files);\n      }\n    };\n    /**\n     * Use a submitButton to upload files from the field given\n     * @param {HTMLInputElement} submitButton the button that the user has to\n     *                           click to start the upload\n     * @param {HTMLInputElement} input the field with the data to upload\n     *\n     * @return {void}\n     */\n\n\n    this.listenOnSubmit = function (submitButton, input) {\n      if (!input.files) return;\n\n      _listenTo(submitButton, \"click\", function () {\n        _baseFileSelectCallback(input.files);\n      }, false);\n    };\n    /**\n     * Use a submitButton to upload files from the field given\n     * @param {HTMLInputElement} submitButton the button that the user has to\n     *                           click to start the upload\n     * @param {Array} array an array of fields with the files to upload\n     *\n     * @return {void}\n     */\n\n\n    this.listenOnArraySubmit = function (submitButton, array) {\n      for (var index in array) {\n        this.listenOnSubmit(submitButton, array[index]);\n      }\n    };\n    /**\n     * Use a file input to activate this instance of the file uploader.\n     * @param  {HTMLInputElement} inpt The input element (e.g., as returned by\n     *                                 document.getElementById(\"yourId\"))\n     * @return {void}\n     */\n\n\n    this.listenOnInput = function (inpt) {\n      if (!inpt.files) return;\n\n      _listenTo(inpt, \"change\", _fileSelectCallback, false);\n    };\n    /**\n     * Accept files dropped on an element and upload them using this instance\n     * of the file uploader.\n     * @param  {HTMLELement} div Any HTML element.  When the user drags a file\n     *                           or files onto this element, those files will\n     *                           be processed by the instance.\n     * @return {void}\n     */\n\n\n    this.listenOnDrop = function (div) {\n      // We need to preventDefault on the dragover event in order for the\n      // drag-and-drop operation to work.\n      _listenTo(div, \"dragover\", function (event) {\n        event.preventDefault();\n      }, false);\n\n      _listenTo(div, \"drop\", _fileSelectCallback);\n    };\n    /**\n     * Display a dialog box for the user to select a file.  The file will then\n     * be uploaded using this instance of SocketIOFileUpload.\n     *\n     * This method works in all current browsers except Firefox, though Opera\n     * requires that the input element be visible.\n     *\n     * @return {void}\n     */\n\n\n    this.prompt = function () {\n      var inpt = _getInputElement(); // Listen for the \"change\" event on the file input element.\n\n\n      _listenTo(inpt, \"change\", _fileSelectCallback, false); // Fire a click event on the input element.  Firefox does not allow\n      // programatic clicks on input elements, but the other browsers do.\n      // Note that Opera requires that the element be visible when \"clicked\".\n\n\n      var evnt = document.createEvent(\"MouseEvents\");\n      evnt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n      inpt.dispatchEvent(evnt);\n    };\n    /**\n     * Destroy an instance of Socket.IO file upload (i.e., unbind events and\n     * relieve memory).\n     *\n     * IMPORTANT: To finish the memory relief process, set all external\n     * references to this instance of SIOFU (including the reference used to\n     * call this destroy function) to null.\n     *\n     * @return {void}\n     */\n\n\n    this.destroy = function () {\n      _stopListening();\n\n      _removeInputElement();\n\n      for (var id in communicators) {\n        if (communicators.hasOwnProperty(id)) {\n          communicators[id].abort = true;\n        }\n      }\n\n      callbacks = null, uploadedFiles = null, readyCallbacks = null, communicators = null;\n    };\n    /**\n     * Registers an event listener.  If the callback function returns false,\n     * the file uploader will stop uploading the current file.\n     * @param  {string}   eventName Type of event for which to listen.\n     * @param  {Function} callback  Listener function.  Will be passed the\n     *                              event as an argument when the event occurs.\n     * @return {void}\n     */\n\n\n    this.addEventListener = function (eventName, callback) {\n      if (!callbacks[eventName]) callbacks[eventName] = [];\n      callbacks[eventName].push(callback);\n    };\n    /**\n     * Removes an event listener.\n     * @param  {string}   eventName Type of event.\n     * @param  {Function} callback  Listener function to remove.\n     * @return {boolean}            true if callback removed; false otherwise\n     */\n\n\n    this.removeEventListener = function (eventName, callback) {\n      if (!callbacks[eventName]) return false;\n\n      for (var i = 0; i < callbacks[eventName].length; i++) {\n        if (callbacks[eventName][i] === callback) {\n          callbacks[eventName].splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Dispatches an event into this instance's event model.\n     * @param  {Event} evnt The event to dispatch.\n     * @return {boolean} false if any callback returned false; true otherwise\n     */\n\n\n    this.dispatchEvent = function (evnt) {\n      var eventCallbacks = callbacks[evnt.type];\n      if (!eventCallbacks) return true;\n      var retVal = true;\n\n      for (var i = 0; i < eventCallbacks.length; i++) {\n        var callbackResult = eventCallbacks[i](evnt);\n\n        if (callbackResult === false) {\n          retVal = false;\n        }\n      }\n\n      return retVal;\n    }; // OTHER LIBRARIES\n\n    /*\n     * base64-arraybuffer\n     * https://github.com/niklasvh/base64-arraybuffer\n     *\n     * Copyright (c) 2012 Niklas von Hertzen\n     * Licensed under the MIT license.\n     *\n     * Adapted for SocketIOFileUpload.\n     */\n\n\n    var _uint8ArrayToBase64 = function (bytes) {\n      var i,\n          len = bytes.buffer.byteLength,\n          base64 = \"\",\n          chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n      for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64 += chars[bytes[i + 2] & 63];\n      }\n\n      if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n      } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n      }\n\n      return base64;\n    }; // END OTHER LIBRARIES\n\n\n    var _chunckCallback = function (data) {\n      if (chunkCallbacks[data.id]) chunkCallbacks[data.id]();\n    };\n\n    var _readyCallback = function (data) {\n      if (readyCallbacks[data.id]) readyCallbacks[data.id](data.name);\n    };\n\n    var _completCallback = function (data) {\n      if (uploadedFiles[data.id]) {\n        _dispatch(\"complete\", {\n          file: uploadedFiles[data.id],\n          detail: data.detail,\n          success: data.success\n        });\n      }\n    };\n\n    var _errorCallback = function (data) {\n      if (uploadedFiles[data.id]) {\n        _dispatch(\"error\", {\n          file: uploadedFiles[data.id],\n          message: data.message,\n          code: 0\n        });\n\n        if (communicators) communicators[data.id].abort = true;\n      }\n    }; // CONSTRUCTOR: Listen to the \"complete\", \"ready\", and \"error\" messages\n    // on the socket.\n\n\n    if (_isWrapDataWellConfigured() && self.wrapData) {\n      var mapActionToCallback = {\n        chunk: _chunckCallback,\n        ready: _readyCallback,\n        complete: _completCallback,\n        error: _errorCallback\n      };\n\n      _listenTo(socket, _getTopicName(), function (message) {\n        if (typeof message !== \"object\") {\n          console.log(\"SocketIOFileUploadClient Error: You choose to wrap your data so the message from the server need to be an object\"); // eslint-disable-line no-console\n\n          return;\n        }\n\n        var actionKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.action === \"string\" ? self.wrapData.unwrapKey.action : \"action\";\n        var messageKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.message === \"string\" ? self.wrapData.unwrapKey.message : \"message\";\n        var action = message[actionKey];\n        var data = message[messageKey];\n\n        if (!action || !data || !mapActionToCallback[action]) {\n          console.log(\"SocketIOFileUploadClient Error: You choose to wrap your data but the message from the server is wrong configured. Check the message and your wrapData option\"); // eslint-disable-line no-console\n\n          return;\n        }\n\n        mapActionToCallback[action](data);\n      });\n    } else {\n      _listenTo(socket, _getTopicName(\"_chunk\"), _chunckCallback);\n\n      _listenTo(socket, _getTopicName(\"_ready\"), _readyCallback);\n\n      _listenTo(socket, _getTopicName(\"_complete\"), _completCallback);\n\n      _listenTo(socket, _getTopicName(\"_error\"), _errorCallback);\n    }\n\n    if (this.exposePrivateFunction) {\n      this.chunckCallback = _chunckCallback;\n      this.readyCallback = _readyCallback;\n      this.completCallback = _completCallback;\n      this.errorCallback = _errorCallback;\n    }\n  };\n});","map":{"version":3,"sources":["/home/mohamed/Desktop/train/react/Chat-Mern/chat-wo2/node_modules/socketio-file-upload/client.js"],"names":["scope","name","factory","define","amd","module","exports","socket","options","self","window","File","FileReader","Error","siofu_global","instances","downloads","callbacks","uploadedFiles","chunkCallbacks","readyCallbacks","communicators","_getOption","key","defaultValue","fileInputElementId","resetFileInputs","useText","serializedOctets","useBuffer","chunkSize","topicName","wrapData","_isWrapDataWellConfigured","Array","isArray","wrapKey","action","message","unwrapKey","exposePrivateFunction","_getTopicName","topicExtension","_wrapData","data","dataWrapped","additionalData","Object","assign","actionKey","messageKey","_dispatch","eventName","properties","evnt","document","createEvent","initEvent","prop","hasOwnProperty","dispatchEvent","_listenedReferences","_listenTo","object","callback","bubble","addEventListener","push","arguments","_stopListeningTo","removeEventListener","_stopListening","i","length","apply","_loadOne","file","maxFileSize","size","code","evntResult","reader","id","uploadComplete","offset","newName","_realReader","communicator","transmitPart","start","end","content","isBase64","uintArr","Uint8Array","buffer","_uint8ArrayToBase64","error","emit","interrupt","base64","transmitDone","processChunk","abort","chunk","slice","Math","min","readAsText","readAsArrayBuffer","loadCb","event","bytesLoaded","target","result","mtime","lastModified","meta","encoding","readyCallback","_newName","chunkCallback","_load","files","_getInputElement","inpt","getElementById","createElement","setAttribute","style","display","body","appendChild","_removeInputElement","parentNode","removeChild","_baseFileSelectCallback","_fileSelectCallback","dataTransfer","preventDefault","value","err","form","ref","nextSibling","reset","insertBefore","submitFiles","listenOnSubmit","submitButton","input","listenOnArraySubmit","array","index","listenOnInput","listenOnDrop","div","prompt","initMouseEvent","destroy","splice","eventCallbacks","type","retVal","callbackResult","bytes","len","byteLength","chars","substring","_chunckCallback","_readyCallback","_completCallback","detail","success","_errorCallback","mapActionToCallback","ready","complete","console","log","chunckCallback","completCallback","errorCallback"],"mappings":"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","sourcesContent":["/*\n *                 Copyright (C) 2015 Shane Carr and others\n *                               X11 License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the names of the authors or copyright\n * holders shall not be used in advertising or otherwise to promote the sale,\n * use or other dealings in this Software without prior written authorization\n * from the authors or copyright holders.\n */\n\n// Do not check function indentation because this is intentionally ignored in order to preserve history in git.\n/* eslint-disable indent */\n\n/*\n * A client-side JavaScript object to handle file uploads to a Node.JS server\n * via Socket.IO.\n * @implements EventTarget\n * @param {SocketIO} socket The current Socket.IO connection.\n */\n(function (scope, name, factory) {\n\t/* eslint-disable no-undef */\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === \"object\" && module.exports) {\n\t\tmodule.exports = factory();\n\t}\n\telse {\n\t\tscope[name] = factory();\n\t}\n\t/* eslint-enable no-undef */\n}(this, \"SocketIOFileUpload\", function () {\n return function (socket, options) {\n\t\"use strict\";\n\n\tvar self = this; // avoids context issues\n\n\t// Check for compatibility\n\tif (!window.File || !window.FileReader) {\n\t\tthrow new Error(\"Socket.IO File Upload: Browser Not Supported\");\n\t}\n\n\tif ( !window.siofu_global ) {\n\t\twindow.siofu_global = {\n\t\t\tinstances: 0,\n\t\t\tdownloads: 0\n\t\t};\n\t}\n\n\t// Private and Public Variables\n\tvar callbacks = {},\n\t\tuploadedFiles = {},\n\t\tchunkCallbacks = {},\n\t\treadyCallbacks = {},\n\t\tcommunicators = {};\n\n\tvar _getOption = function (key, defaultValue) {\n\t\tif(!options) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn options[key] || defaultValue;\n\t};\n\n\tself.fileInputElementId = \"siofu_input_\"+window.siofu_global.instances++;\n\tself.resetFileInputs = true;\n\tself.useText = _getOption(\"useText\", false);\n\tself.serializedOctets = _getOption(\"serializedOctets\", false);\n\tself.useBuffer = _getOption(\"useBuffer\", true);\n\tself.chunkSize = _getOption(\"chunkSize\", 1024 * 100); // 100kb default chunk size\n\tself.topicName = _getOption(\"topicName\", \"siofu\");\n\n\t/**\n\t* WrapData allow you to wrap the Siofu messages into a predefined format.\n\t* You can then easily use Siofu packages even in strongly typed topic.\n\t* wrapData can be a boolean or an object. It is false by default.\n\t* If wrapData is true it will allow you to send all the messages to only one topic by wrapping the siofu actions and messages.\n\t*\n\t* ex:\n\t{\n\t\taction: 'complete',\n\t\tmessage: {\n\t\t id: id,\n\t\t success: success,\n\t\t detail: fileInfo.clientDetail\n\t\t}\n\t}\n\t*\n\t* If wrapData is an object constituted of two mandatory key and one optional:\n\t* wrapKey and unwrapKey (mandatory): Corresponding to the key used to wrap the siofu data and message\n\t* additionalData (optional): Corresponding to the data to send along with file data\n\t*\n\t* ex:\n\t* if wrapData = {\n\t\twrapKey: {\n\t\t\taction: 'actionType',\n\t\t\tmessage: 'data'\n\t\t},\n\t\tunwrapKey: {\n\t\t\taction: 'actionType',\n\t\t\tmessage: 'message'\n\t\t},\n\t\tadditionalData: {\n\t\t\tacknowledgement: true\n\t\t}\n\t}\n\t* When Siofu will send for example a complete message this will send:\n\t*\n\t{\n\t\tacknowledgement: true,\n\t\tactionType: 'complete',\n\t\tdata: {\n\t\t id: id,\n\t\t success: success,\n\t\t detail: fileInfo.clientDetail\n\t\t}\n\t}\n\t* and it's waiting from client data formatted like this:\n\t*\n\t{\n\t\tactionType: '...',\n\t\tmessage: {...}\n\t}\n\t* /!\\ If wrapData is wrong configured is interpreted as false /!\\\n\t*/\n\tself.wrapData = _getOption(\"wrapData\", false);\n\n\tvar _isWrapDataWellConfigured = function () {\n\t\tif (typeof self.wrapData === \"boolean\") {\n\t\t\treturn true;\n\t\t}\n\t\tif (typeof self.wrapData !== \"object\" || Array.isArray(self.wrapData)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(!self.wrapData.wrapKey || typeof self.wrapData.wrapKey.action !== \"string\" || typeof self.wrapData.wrapKey.message !== \"string\" ||\n\t\t\t!self.wrapData.unwrapKey || typeof self.wrapData.unwrapKey.action !== \"string\" || typeof self.wrapData.unwrapKey.message !== \"string\") {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Allow user to access to some private function to customize message reception.\n\t * This is used if you specified wrapOptions on the client side and have to manually bind message to callback.\n\t */\n\tself.exposePrivateFunction = _getOption(\"exposePrivateFunction\", false);\n\n\tvar _getTopicName = function (topicExtension) {\n\t\tif (self.wrapData) {\n\t\t\treturn self.topicName;\n\t\t}\n\n\t\treturn self.topicName + topicExtension;\n\t};\n\n\tvar _wrapData = function (data, action) {\n\t\tif(!_isWrapDataWellConfigured() || !self.wrapData) {\n\t\t\treturn data;\n\t\t}\n\t\tvar dataWrapped = {};\n\t\tif(self.wrapData.additionalData) {\n\t\t\tObject.assign(dataWrapped, self.wrapData.additionalData);\n\t\t}\n\n\t\tvar actionKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.action === \"string\" ? self.wrapData.wrapKey.action : \"action\";\n\t\tvar messageKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.message === \"string\" ? self.wrapData.wrapKey.message : \"message\";\n\n\t\tdataWrapped[actionKey] = action;\n\t\tdataWrapped[messageKey] = data;\n\t\treturn dataWrapped;\n\t};\n\n\t/**\n\t * Private method to dispatch a custom event on the instance.\n\t * @param  {string} eventName  Name for which listeners can listen.\n\t * @param  {object} properties An object literal with additional properties\n\t *                             to be attached to the event object.\n\t * @return {boolean} false if any callback returned false; true otherwise\n\t */\n\tvar _dispatch = function (eventName, properties) {\n\t\tvar evnt = document.createEvent(\"Event\");\n\t\tevnt.initEvent(eventName, false, false);\n\t\tfor (var prop in properties) {\n\t\t\tif (properties.hasOwnProperty(prop)) {\n\t\t\t\tevnt[prop] = properties[prop];\n\t\t\t}\n\t\t}\n\t\treturn self.dispatchEvent(evnt);\n\t};\n\n\t/**\n\t * Private method to bind an event listener.  Useful to ensure that all\n\t * events have been unbound.  Inspired by Backbone.js.\n\t */\n\tvar _listenedReferences = [];\n\tvar _listenTo = function (object, eventName, callback, bubble) {\n\t\tobject.addEventListener(eventName, callback, bubble);\n\t\t_listenedReferences.push(arguments);\n\t};\n\tvar _stopListeningTo = function (object, eventName, callback, bubble) {\n\t\tif (object.removeEventListener) {\n\t\t\tobject.removeEventListener(eventName, callback, bubble);\n\t\t}\n\t};\n\tvar _stopListening = function () {\n\t\tfor (var i = _listenedReferences.length - 1; i >= 0; i--) {\n\t\t\t_stopListeningTo.apply(this, _listenedReferences[i]);\n\t\t}\n\t\t_listenedReferences = [];\n\t};\n\n\t/**\n\t * Private closure for the _load function.\n\t * @param  {File} file A W3C File object\n\t * @return {void}\n\t */\n\tvar _loadOne = function (file) {\n\t\t// First check for file size\n\t\tif (self.maxFileSize !== null && file.size > self.maxFileSize) {\n\t\t\t_dispatch(\"error\", {\n\t\t\t\tfile: file,\n\t\t\t\tmessage: \"Attempt by client to upload file exceeding the maximum file size\",\n\t\t\t\tcode: 1\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Dispatch an event to listeners and stop now if they don't want\n\t\t// this file to be uploaded.\n\t\tvar evntResult = _dispatch(\"start\", {\n\t\t\tfile: file\n\t\t});\n\t\tif (!evntResult) return;\n\n\t\t// Scope variables\n\t\tvar reader = new FileReader(),\n\t\t\tid = window.siofu_global.downloads++,\n\t\t\tuploadComplete = false,\n\t\t\tuseText = self.useText,\n\t\t\toffset = 0,\n\t\t\tnewName;\n\t\tif (reader._realReader) reader = reader._realReader; // Support Android Crosswalk\n\t\tuploadedFiles[id] = file;\n\n\t\t// An object for the outside to use to communicate with us\n\t\tvar communicator = { id: id };\n\n\t\t// Calculate chunk size\n\t\tvar chunkSize = self.chunkSize;\n\t\tif (chunkSize >= file.size || chunkSize <= 0) chunkSize = file.size;\n\n\t\t// Private function to handle transmission of file data\n\t\tvar transmitPart = function (start, end, content) {\n\t\t\tvar isBase64 = false;\n\t\t\tif (!useText) {\n\t\t\t\ttry {\n\t\t\t\t\tvar uintArr = new Uint8Array(content);\n\n\t\t\t\t\t// Support the transmission of serialized ArrayBuffers\n\t\t\t\t\t// for experimental purposes, but default to encoding the\n\t\t\t\t\t// transmission in Base 64.\n\t\t\t\t\tif (self.serializedOctets) {\n\t\t\t\t\t\tcontent = uintArr;\n\t\t\t\t\t}\n\t\t\t\t\telse if (self.useBuffer) {\n\t\t\t\t\t\tcontent = uintArr.buffer;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisBase64 = true;\n\t\t\t\t\t\tcontent = _uint8ArrayToBase64(uintArr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tinterrupt: true\n\t\t\t\t\t}, \"done\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO override the send data\n\t\t\tsocket.emit(_getTopicName(\"_progress\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tsize: file.size,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tcontent: content,\n\t\t\t\tbase64: isBase64\n\t\t\t}, \"progress\"));\n\t\t};\n\n\t\t// Callback when tranmission is complete.\n\t\tvar transmitDone = function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id\n\t\t\t}, \"done\"));\n\t\t};\n\n\t\t// Load a \"chunk\" of the file from offset to offset+chunkSize.\n\t\t//\n\t\t// Note that FileReader has its own \"progress\" event.  However,\n\t\t// it has not proven to be reliable enough for production. See\n\t\t// Stack Overflow question #16713386.\n\t\t//\n\t\t// To compensate, we will manually load the file in chunks of a\n\t\t// size specified by the user in the uploader.chunkSize property.\n\t\tvar processChunk = function () {\n\t\t\t// Abort if we are told to do so.\n\t\t\tif (communicator.abort) return;\n\n\t\t\tvar chunk = file.slice(offset, Math.min(offset+chunkSize, file.size));\n\t\t\tif (useText) {\n\t\t\t\treader.readAsText(chunk);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treader.readAsArrayBuffer(chunk);\n\t\t\t}\n\t\t};\n\n\t\t// Callback for when the reader has completed a load event.\n\t\tvar loadCb = function (event) {\n\t\t\t// Abort if we are told to do so.\n\t\t\tif (communicator.abort) return;\n\n\t\t\t// Transmit the newly loaded data to the server and emit a client event\n\t\t\tvar bytesLoaded = Math.min(offset+chunkSize, file.size);\n\t\t\ttransmitPart(offset, bytesLoaded, event.target.result);\n\t\t\t_dispatch(\"progress\", {\n\t\t\t\tfile: file,\n\t\t\t\tbytesLoaded: bytesLoaded,\n\t\t\t\tname: newName\n\t\t\t});\n\n\t\t\t// Get ready to send the next chunk\n\t\t\toffset += chunkSize;\n\t\t\tif (offset >= file.size) {\n\t\t\t\t// All done!\n\t\t\t\ttransmitDone();\n\t\t\t\t_dispatch(\"load\", {\n\t\t\t\t\tfile: file,\n\t\t\t\t\treader: reader,\n\t\t\t\t\tname: newName\n\t\t\t\t});\n\t\t\t\tuploadComplete = true;\n\t\t\t}\n\t\t};\n\t\t_listenTo(reader, \"load\", loadCb);\n\n\t\t// Listen for an \"error\" event.  Stop the transmission if one is received.\n\t\t_listenTo(reader, \"error\", function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tinterrupt: true\n\t\t\t}, \"done\"));\n\t\t\t_stopListeningTo(reader, \"load\", loadCb);\n\t\t});\n\n\t\t// Do the same for the \"abort\" event.\n\t\t_listenTo(reader, \"abort\", function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tinterrupt: true\n\t\t\t}, \"done\"));\n\t\t\t_stopListeningTo(reader, \"load\", loadCb);\n\t\t});\n\n\t\t// Transmit the \"start\" message to the server.\n\t\tsocket.emit(_getTopicName(\"_start\"), _wrapData({\n\t\t\tname: file.name,\n\t\t\tmtime: file.lastModified,\n\t\t\tmeta: file.meta,\n\t\t\tsize: file.size,\n\t\t\tencoding: useText ? \"text\" : \"octet\",\n\t\t\tid: id\n\t\t}, \"start\"));\n\n\t\t// To avoid a race condition, we don't want to start transmitting to the\n\t\t// server until the server says it is ready.\n\t\tvar readyCallback = function (_newName) {\n\t\t\tnewName = _newName;\n\t\t\tprocessChunk();\n\t\t};\n\t\tvar chunkCallback = function(){\n\t\t\tif ( !uploadComplete )\n\t\t\t\tprocessChunk();\n\t\t};\n\t\treadyCallbacks[id] = readyCallback;\n\t\tchunkCallbacks[id] = chunkCallback;\n\n\t\treturn communicator;\n\t};\n\n\t/**\n\t * Private function to load the file into memory using the HTML5 FileReader object\n\t * and then transmit that file through Socket.IO.\n\t *\n\t * @param  {FileList} files An array of files\n\t * @return {void}\n\t */\n\tvar _load = function (files) {\n\t\t// Iterate through the array of files.\n\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\t// Evaluate each file in a closure, because we will need a new\n\t\t\t// instance of FileReader for each file.\n\t\t\tvar communicator = _loadOne(files[i]);\n\t\t\tcommunicators[communicator.id] = communicator;\n\t\t}\n\t};\n\n\t/**\n\t * Private function to fetch an HTMLInputElement instance that can be used\n\t * during the file selection process.\n\t * @return {void}\n\t */\n\tvar _getInputElement = function () {\n\t\tvar inpt = document.getElementById(self.fileInputElementId);\n\t\tif (!inpt) {\n\t\t\tinpt = document.createElement(\"input\");\n\t\t\tinpt.setAttribute(\"type\", \"file\");\n\t\t\tinpt.setAttribute(\"id\", self.fileInputElementId);\n\t\t\tinpt.style.display = \"none\";\n\t\t\tdocument.body.appendChild(inpt);\n\t\t}\n\t\treturn inpt;\n\t};\n\n\t/**\n\t * Private function to remove an HTMLInputElement created by this instance\n\t * of SIOFU.\n\t *\n\t * @return {void}\n\t */\n\tvar _removeInputElement = function () {\n\t\tvar inpt = document.getElementById(self.fileInputElementId);\n\t\tif (inpt) {\n\t\t\tinpt.parentNode.removeChild(inpt);\n\t\t}\n\t};\n\n\tvar _baseFileSelectCallback = function (files) {\n\t\tif (files.length === 0) return;\n\n\t\t// Ensure existence of meta property on each file\n\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\tif(!files[i].meta) files[i].meta = {};\n\t\t}\n\n\t\t// Dispatch the \"choose\" event\n\t\tvar evntResult = _dispatch(\"choose\", {\n\t\t\tfiles: files\n\t\t});\n\n\t\t// If the callback didn't return false, continue with the upload\n\t\tif (evntResult) {\n\t\t\t_load(files);\n\t\t}\n\t};\n\n\t/**\n\t * Private function that serves as a callback on file input.\n\t * @param  {Event} event The file input change event\n\t * @return {void}\n\t */\n\tvar _fileSelectCallback = function (event) {\n\t\tvar files = event.target.files || event.dataTransfer.files;\n\t\tevent.preventDefault();\n\t\t_baseFileSelectCallback(files);\n\n\t\tif (self.resetFileInputs) {\n\t\t\ttry {\n\t\t\t\tevent.target.value = \"\"; //for IE11, latest Chrome/Firefox/Opera...\n\t\t\t} catch(err) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\tif (event.target.value) { //for IE5 ~ IE10\n\t\t\t\tvar form = document.createElement(\"form\"),\n\t\t\t\tparentNode = event.target.parentNode, ref = event.target.nextSibling;\n\t\t\t\tform.appendChild(event.target);\n\t\t\t\tform.reset();\n\t\t\t\tparentNode.insertBefore(event.target, ref);\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/**\n\t * Submit files at arbitrary time\n\t * @param {FileList} files Files received form the input element.\n\t * @return {void}\n\t */\n\tthis.submitFiles = function (files) {\n\t\tif (files) {\n\t\t\t_baseFileSelectCallback(files);\n\t\t}\n\t};\n\n\t/**\n\t * Use a submitButton to upload files from the field given\n\t * @param {HTMLInputElement} submitButton the button that the user has to\n\t *                           click to start the upload\n\t * @param {HTMLInputElement} input the field with the data to upload\n\t *\n\t * @return {void}\n\t */\n\tthis.listenOnSubmit = function (submitButton, input) {\n\t\tif (!input.files) return;\n\t\t_listenTo(submitButton, \"click\", function () {\n\t\t\t_baseFileSelectCallback(input.files);\n\t\t}, false);\n\t};\n\n\t/**\n\t * Use a submitButton to upload files from the field given\n\t * @param {HTMLInputElement} submitButton the button that the user has to\n\t *                           click to start the upload\n\t * @param {Array} array an array of fields with the files to upload\n\t *\n\t * @return {void}\n\t */\n\tthis.listenOnArraySubmit = function (submitButton, array) {\n\t\tfor (var index in array) {\n\t\t\tthis.listenOnSubmit(submitButton, array[index]);\n\t\t}\n\t};\n\n\t/**\n\t * Use a file input to activate this instance of the file uploader.\n\t * @param  {HTMLInputElement} inpt The input element (e.g., as returned by\n\t *                                 document.getElementById(\"yourId\"))\n\t * @return {void}\n\t */\n\tthis.listenOnInput = function (inpt) {\n\t\tif (!inpt.files) return;\n\t\t_listenTo(inpt, \"change\", _fileSelectCallback, false);\n\t};\n\n\t/**\n\t * Accept files dropped on an element and upload them using this instance\n\t * of the file uploader.\n\t * @param  {HTMLELement} div Any HTML element.  When the user drags a file\n\t *                           or files onto this element, those files will\n\t *                           be processed by the instance.\n\t * @return {void}\n\t */\n\tthis.listenOnDrop = function (div) {\n\t\t// We need to preventDefault on the dragover event in order for the\n\t\t// drag-and-drop operation to work.\n\t\t_listenTo(div, \"dragover\", function (event) {\n\t\t\tevent.preventDefault();\n\t\t}, false);\n\n\t\t_listenTo(div, \"drop\", _fileSelectCallback);\n\t};\n\n\t/**\n\t * Display a dialog box for the user to select a file.  The file will then\n\t * be uploaded using this instance of SocketIOFileUpload.\n\t *\n\t * This method works in all current browsers except Firefox, though Opera\n\t * requires that the input element be visible.\n\t *\n\t * @return {void}\n\t */\n\tthis.prompt = function () {\n\t\tvar inpt = _getInputElement();\n\n\t\t// Listen for the \"change\" event on the file input element.\n\t\t_listenTo(inpt, \"change\", _fileSelectCallback, false);\n\n\t\t// Fire a click event on the input element.  Firefox does not allow\n\t\t// programatic clicks on input elements, but the other browsers do.\n\t\t// Note that Opera requires that the element be visible when \"clicked\".\n\t\tvar evnt = document.createEvent(\"MouseEvents\");\n\t\tevnt.initMouseEvent(\"click\", true, true, window,\n\t\t\t0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\tinpt.dispatchEvent(evnt);\n\t};\n\n\t/**\n\t * Destroy an instance of Socket.IO file upload (i.e., unbind events and\n\t * relieve memory).\n\t *\n\t * IMPORTANT: To finish the memory relief process, set all external\n\t * references to this instance of SIOFU (including the reference used to\n\t * call this destroy function) to null.\n\t *\n\t * @return {void}\n\t */\n\tthis.destroy = function () {\n\t\t_stopListening();\n\t\t_removeInputElement();\n\t\tfor (var id in communicators) {\n\t\t\tif (communicators.hasOwnProperty(id)) {\n\t\t\t\tcommunicators[id].abort = true;\n\t\t\t}\n\t\t}\n\t\tcallbacks = null, uploadedFiles = null, readyCallbacks = null, communicators = null;\n\t};\n\n\t/**\n\t * Registers an event listener.  If the callback function returns false,\n\t * the file uploader will stop uploading the current file.\n\t * @param  {string}   eventName Type of event for which to listen.\n\t * @param  {Function} callback  Listener function.  Will be passed the\n\t *                              event as an argument when the event occurs.\n\t * @return {void}\n\t */\n\tthis.addEventListener = function (eventName, callback) {\n\t\tif (!callbacks[eventName]) callbacks[eventName] = [];\n\t\tcallbacks[eventName].push(callback);\n\t};\n\n\t/**\n\t * Removes an event listener.\n\t * @param  {string}   eventName Type of event.\n\t * @param  {Function} callback  Listener function to remove.\n\t * @return {boolean}            true if callback removed; false otherwise\n\t */\n\tthis.removeEventListener = function (eventName, callback) {\n\t\tif (!callbacks[eventName]) return false;\n\t\tfor (var i = 0; i < callbacks[eventName].length; i++) {\n\t\t\tif (callbacks[eventName][i] === callback) {\n\t\t\t\tcallbacks[eventName].splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Dispatches an event into this instance's event model.\n\t * @param  {Event} evnt The event to dispatch.\n\t * @return {boolean} false if any callback returned false; true otherwise\n\t */\n\tthis.dispatchEvent = function (evnt) {\n\t\tvar eventCallbacks = callbacks[evnt.type];\n\t\tif (!eventCallbacks) return true;\n\t\tvar retVal = true;\n\t\tfor (var i = 0; i < eventCallbacks.length; i++) {\n\t\t\tvar callbackResult = eventCallbacks[i](evnt);\n\t\t\tif (callbackResult === false) {\n\t\t\t\tretVal = false;\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t};\n\n\t// OTHER LIBRARIES\n\t/*\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t *\n\t * Adapted for SocketIOFileUpload.\n\t */\n\tvar _uint8ArrayToBase64 = function (bytes) {\n\t\tvar i, len = bytes.buffer.byteLength, base64 = \"\",\n\t\t\tchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\t\tfor (i = 0; i < len; i += 3) {\n\t\t\tbase64 += chars[bytes[i] >> 2];\n\t\t\tbase64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t\t\tbase64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t\t\tbase64 += chars[bytes[i + 2] & 63];\n\t\t}\n\n\t\tif ((len % 3) === 2) {\n\t\t\tbase64 = base64.substring(0, base64.length - 1) + \"=\";\n\t\t}\n\t\telse if (len % 3 === 1) {\n\t\t\tbase64 = base64.substring(0, base64.length - 2) + \"==\";\n\t\t}\n\n\t\treturn base64;\n\t};\n\t// END OTHER LIBRARIES\n\tvar _chunckCallback = function(data) {\n\t\tif ( chunkCallbacks[data.id] )\n\t\t\tchunkCallbacks[data.id]();\n\t};\n\n\tvar _readyCallback = function (data) {\n\t\tif (readyCallbacks[data.id])\n\t\t\treadyCallbacks[data.id](data.name);\n\t};\n\n\tvar _completCallback = function (data) {\n\t\tif (uploadedFiles[data.id]) {\n\t\t\t_dispatch(\"complete\", {\n\t\t\t\tfile: uploadedFiles[data.id],\n\t\t\t\tdetail: data.detail,\n\t\t\t\tsuccess: data.success\n\t\t\t});\n\t\t}\n\t};\n\n\tvar _errorCallback = function (data) {\n\t\tif ( uploadedFiles[data.id] ) {\n\t\t\t_dispatch(\"error\", {\n\t\t\t\tfile: uploadedFiles[data.id],\n\t\t\t\tmessage: data.message,\n\t\t\t\tcode: 0\n\t\t\t});\n\t\t\tif (communicators) communicators[data.id].abort = true;\n\t\t}\n\t};\n\n\t// CONSTRUCTOR: Listen to the \"complete\", \"ready\", and \"error\" messages\n\t// on the socket.\n\tif (_isWrapDataWellConfigured() && self.wrapData) {\n\t\tvar mapActionToCallback = {\n\t\t\tchunk: _chunckCallback,\n\t\t\tready: _readyCallback,\n\t\t\tcomplete: _completCallback,\n\t\t\terror: _errorCallback\n\t\t};\n\n\t\t_listenTo(socket, _getTopicName(), function (message) {\n\t\t\tif (typeof message !== \"object\") {\n\t\t\t\tconsole.log(\"SocketIOFileUploadClient Error: You choose to wrap your data so the message from the server need to be an object\"); // eslint-disable-line no-console\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar actionKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.action === \"string\" ? self.wrapData.unwrapKey.action : \"action\";\n\t\t\tvar messageKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.message === \"string\" ? self.wrapData.unwrapKey.message : \"message\";\n\n\t\t\tvar action = message[actionKey];\n\t\t\tvar data = message[messageKey];\n\t\t\tif (!action || !data || !mapActionToCallback[action]) {\n\t\t\t\tconsole.log(\"SocketIOFileUploadClient Error: You choose to wrap your data but the message from the server is wrong configured. Check the message and your wrapData option\"); // eslint-disable-line no-console\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmapActionToCallback[action](data);\n\t\t});\n\t} else {\n\t\t_listenTo(socket, _getTopicName(\"_chunk\"), _chunckCallback);\n\t\t_listenTo(socket, _getTopicName(\"_ready\"), _readyCallback);\n\t\t_listenTo(socket, _getTopicName(\"_complete\"), _completCallback);\n\t\t_listenTo(socket, _getTopicName(\"_error\"), _errorCallback);\n\t}\n\n\tif (this.exposePrivateFunction) {\n\t\tthis.chunckCallback = _chunckCallback;\n\t\tthis.readyCallback = _readyCallback;\n\t\tthis.completCallback = _completCallback;\n\t\tthis.errorCallback = _errorCallback;\n\t}\n };\n}));\n"]},"metadata":{},"sourceType":"script"}